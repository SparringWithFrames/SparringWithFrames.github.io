---
layout: post
title:  "Mind The Chain Post Mortem"
date:   2019-12-31 15:35:29 -0500
categories: games
---

![And away we go...](/assets/img/mindthechaincover.PNG)

I would say one of the most striking things that I noticed throughout development of Mind the Chain was just how far apart my iterations were between designing the game and the actual engineering aspects required to make that a reality.
When the jam started and the theme revealed, my original idea involved a completely physics based chain latched onto the main character from a singular point in the environment. The main gameplay loop would involve using the chain to solve physics based puzzles, 
such as wrapping the chain around objects to apply pressure. I spent a good amount of time building a paper prototype of the concept. The problem here is my knowledge of physics, trigonometry, calculus, etc. (anything that really makes a game engine hum) is pretty bare. 

Now if, unlike me, you are experienced in these areas, i'm sure you are getting a good chuckle out of my naivety.  By the time I finished my paper prototype, began production, and started working with Unreal's cable component, I learned what Verlet Integration was, and just how impovishered my understanding of the area really is. 
So my original idea had to pretty much be scrapped. What resulted was what you see in the end product, which is a grid with node states like you see in a fundamental searching algorithms (this also posed it's own issues for me, more on that later). However, by not having a much tighter engineering iteration to actually assess the viability of production of said mechanics, 
I ended up losing a couple of days of work. 

I realized my mistake, and harmoniously brought a meaningfull synchronicity between my elements of engineering and design. Just kidding, that didn't happen. I ended up falling off the 'other' side of the wagon. By not having a clear design goal in mind anymore and panic setting in, I retreated to the one skill that I have, programming, and started to build whatever mechanic that I could think of that could coalesce into a working game. In of itself, I don't think this is a bad thing. I've seen industry people talking about this and experimentation is a hallmark of prototyping. By having workable pieces that 'did something', I had mechanics emerge that I could utilize in the absence of any kind of directed design, but towards the end as the scope of my code base grew, I started to experience pains due to the abandonement of any kind of design prototype. A perfect example of this is how the power system works. 

As your character establishes more links in the chain, your power level grows. It updates the materials of the chain, and once you hit a power level of four or 'red' your movement starts to slow down drastically from the point you became connected. You can either walk back the way you came, or later on, use the power to open up a portal or flip the gravity of the map. While this loop became my core mechanic due to everything coalescing together, I didn't pay much heed to what happens after your character arrives at this state. I made it so once you 'activate' a node, it reduces the power level and makes it so by going to that node, any power updates are ignored. I did this as a matter of convenience for the player and because I just didn't have that much time to actually design levels by the end of the jam, but it left with a different problem. What's to stop the player from just chaining node activations, which completely circumvents my core mechanic? When it came to the design aspect of the game, this caused me some pain, and i ended up creating more work for myself to get around it (such as a magically appearing wall that appears when a player steps on an unavoidable piece of floor, forcing the necesitty of using a portal to avoid the floor).

Thankfully, I believe this is one of the easiest things I can improve upon with experience. At the end of the project, it wasn't really difficult at all to understand what went wrong with both of these aspects, and I started to think of the act of building games differently afterwards.

From an engineering standpoint, while I was far more comfortable in those aspects, what I was able to achieve didn't sit well with me by the end of the project. There were a lot of traps and bad habits that I fell into that I've developed over the past couple of years while I was working on enterprise level applications. I didn't really grasp Unreal's blueprint communication and elements of event driven design until the end of the project. So a lot of stuff got baked into overlaps and triggers. This is how the cable system ended up working. Instead of building an honest to god graph algorithm that I could run to keep everything in check, I ended up simulating the functionality with direct object references for nearest neighbor cable nodes with overlaps, and the end result was pretty dissappointing after more testing. Fuzzy movements between different cable zones completely bricked the implementation.

I'm not the best with adopting industry common patterns. I was probably asleep in college when my professors went over the gang of four, and while I know it isn't a good idea to be dogmatic about design methodologies in programming, I could stand to hit the mental gym and put some of them to practice to find what works for me. It's far better than developing tunnel vision and ending up with more sphagetti than less. I'm giving Robert Nystrom a reread after this, and some trigonometry, and linear algebra, and physics. =)

Another mistake I made was writing arbitrary code in C++ that I feel like I could have done in blueprints with no discernable performance loss. While I know one of the mechanics I needed (implementing slowdown at max power based on distance from entry point, ticking on every frame once triggered), the majority of what I wrote was some pretty boilerplate stuff involving power levels and what not. I felt like I needed to write some C++ so I could be a real boy.. ahem.. programmer. I fully expect to work more with and get used to it (including what I need and dont need to put in C++) as I progress. 

As far as the art goes, I'm trying not to put too much of an emphasis on it. Shit is hard, and tiring, and artists are absolutely worth every penny. The only thing I made myself were a couple of materials, and the portal/gravity gun, which took me upwards of an entire day to block out, uv, and paint to get it functional in game, and that was an extremely low poly model. Most of the architecture seen in the levels were very much 'stream of conciousness' that stream being 'oh shit I only have 72 hours left to get these levels done'. To be honest, I'm more interested in the psychological aspects that ultimately lead to the art that is produced in games. I've been spending a lot of time getting into architecture as I've been doing this and I don't expect that to change any time soon because it's applicable to pretty much everything. By studying these things I hope to be able to have more nuanced conversations with artists about these things to enhance our communications and build a better understanding. This is why i'm putting Houdini as something pretty high on my list of things to learn, even as a non artist. Not because I think I'll create anything impressive with it, but because I think it can be a physical enabler for those types of discussions.